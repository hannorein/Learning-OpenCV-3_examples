#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>

#include <stdio.h>
#include <iostream>
#include <sstream>
#include <sys/time.h>

long getMicrotime(){
	struct timeval currentTime;
	gettimeofday(&currentTime, NULL);
	return currentTime.tv_sec * (int)1e6 + currentTime.tv_usec;
}


using namespace cv;
using namespace std;
Mat frame; //current frame
Mat mask; //fg mask fg mask generated by MOG2 method

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

long start_time = 0;
long last_time = 0;
long last_pos = 0;
const int Nlog = 10;
double last_speed[Nlog];

int main(int argc, char* argv[])
{
    start_time = getMicrotime();
    //create GUI windows
    namedWindow("Frame");
    namedWindow("Mask");
    moveWindow("Frame", 650,0);

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    VideoCapture capture;
    capture.open(0);  
    capture.set(CV_CAP_PROP_FRAME_WIDTH,640);
    capture.set(CV_CAP_PROP_FRAME_HEIGHT,480);
    if(!capture.isOpened()){
        cerr << "Unable to open video stream." << endl;
        exit(EXIT_FAILURE);
    }
    
    double learning_rate = 0.01;
    int keyboard = 0;
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            exit(EXIT_FAILURE);
        }
        blur( frame, frame, Size( 2, 2 ), Point(-1,-1) );
        pMOG2->apply(frame, mask, learning_rate);
        Mat sum;
        reduce(mask, sum, 0, CV_REDUCE_SUM, CV_32S);
       
        int min_length = 20;
        int cur_pos = -1;
        uint32_t max = 0;
        for (int i=0;i<sum.cols-min_length;i++){
            uint32_t c = sum.at<uint32_t>(0,i);
            max = max<c?c:max;
        }
        if (max>10000){
            for (int i=0;i<sum.cols-min_length;i++){
                int passed = 1;
                for (int j=i;j<i+min_length;j++){
                    if (sum.at<uint32_t>(0,i)<max/4){
                        passed = 0;
                    }
                }
                if (passed){
                    cur_pos = i;
                    break;
                }
            }
        }
        double speed = 0;
        long cur_time = getMicrotime();
        if (cur_pos>0){
            if (cur_time-last_time<100*1000 && last_pos > cur_pos){
                speed =  1e6*((double)(last_pos - cur_pos))/((double)(cur_time-last_time)); 
            }
            last_time = cur_time;
            last_pos = cur_pos;
        }
        for (int i=1;i<Nlog;i++){
            last_speed[i-1] = last_speed[i];
        }
        last_speed[Nlog-1] = speed;
        double avg = 0;
        for (int i=0;i<Nlog;i++){
            avg+= last_speed[i];
        }
        avg /= (double) Nlog;
        int consistent = 1;
        for (int i=0;i<Nlog;i++){
            double rel = fabs((avg- last_speed[i])/avg);
            if (rel>1.2 || rel < 0.8){
                consistent = 0;
            }
        }


        cout << (cur_time-start_time)/1e6 << "\t" << speed << "\t" << consistent <<endl;


        stringstream ss;
        ss << "Speed: " << speed;
        putText(mask, ss.str().c_str(), cvPoint(30,420), 
                    FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);

        imshow("Frame", frame);
        imshow("Mask", mask);
		keyboard = waitKey(1); 
    }
    capture.release();
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}
