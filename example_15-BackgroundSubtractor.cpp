#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>

#include <stdio.h>
#include <iostream>
#include <sstream>
#include <sys/time.h>

long getMicrotime(){
	struct timeval currentTime;
	gettimeofday(&currentTime, NULL);
	return currentTime.tv_sec * (int)1e6 + currentTime.tv_usec;
}


using namespace cv;
using namespace std;
Mat frame; //current frame
Mat mask; //fg mask fg mask generated by MOG2 method

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

long start_time = 0;
long last_time = 0;
long last_pos = 0;

int main(int argc, char* argv[])
{
    start_time = getMicrotime();
    //create GUI windows
    namedWindow("Frame");
    namedWindow("Mask");
    moveWindow("Frame", 650,0);

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    VideoCapture capture;
    capture.open(0);  
    capture.set(CV_CAP_PROP_FRAME_WIDTH,640);
    capture.set(CV_CAP_PROP_FRAME_HEIGHT,480);
    if(!capture.isOpened()){
        cerr << "Unable to open video stream." << endl;
        exit(EXIT_FAILURE);
    }
    
    double learning_rate = 0.01;
    int keyboard = 0;
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            exit(EXIT_FAILURE);
        }
        pMOG2->apply(frame, mask, learning_rate);
        imshow("Frame", frame);
        imshow("Mask", mask);
        Mat sum;
        reduce(mask, sum, 0, CV_REDUCE_SUM, CV_32S);
       
        uint32_t threshold = 5000; 
        int min_length = 10;
        int cur_pos = -1;
        for (int i=0;i<sum.cols-min_length;i++){
            int passed = 1;
            for (int j=i;j<i+min_length;j++){
                if (sum.at<uint32_t>(0,i)<threshold){
                    passed = 0;
                }
            }
            if (passed){
                cur_pos = i;
                break;
            }
        }
        double speed = 0;
        long cur_time = getMicrotime();
        if (cur_pos>0){
            if (cur_time-last_time<100*1000 && last_pos > cur_pos){
                speed =  1e6*((double)(last_pos - cur_pos))/((double)(cur_time-last_time)); 
            }
            last_time = cur_time;
            last_pos = cur_pos;
        }
        cout << (cur_time-start_time)/1e6 << "\t" << speed  <<endl;


		keyboard = waitKey(1); 
    }
    capture.release();
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}
